{"version":3,"sources":["src/lexer.js"],"names":["DOUBLEQUOTE","BRACKETLEFT","BRACKETRIGHT","SEMICOLON","NEWLINE","WHITESPACE","lispLexer","payload","inString","tokens","curToken","i","length","char","charAt","console","log","tokenized","remaining","substring","push","includes"],"mappings":"AAAA,MAAMA,WAAW,GAAI,GAArB;AACA,MAAMC,WAAW,GAAI,GAArB;AACA,MAAMC,YAAY,GAAI,GAAtB;AACA,MAAMC,SAAS,GAAI,GAAnB;AACA,MAAMC,OAAO,GAAI,IAAjB;AACA,MAAMC,UAAU,GAAG,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAnB;;AAEA,SAASC,SAAT,CAAmBC,OAAO,GAAG,EAA7B,EAAiCC,QAAQ,GAAG,KAA5C,EAAmD;AACjD,QAAMC,MAAM,GAAG,EAAf;AACA,MAAIC,QAAQ,GAAG,EAAf;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAACK,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,UAAME,IAAI,GAAGN,OAAO,CAACO,MAAR,CAAeH,CAAf,CAAb;;AACA,QAAIE,IAAI,KAAKb,WAAT,IAAwBQ,QAAQ,KAAK,KAAzC,EAAgD;AAC9CO,MAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ;AACA,YAAM,CAACC,SAAD,EAAYC,SAAZ,IAAyBZ,SAAS,CAACC,OAAO,CAACY,SAAR,CAAkBR,CAAC,GAAG,CAAtB,CAAD,EAA2B,IAA3B,CAAxC;AACAF,MAAAA,MAAM,CAACW,IAAP,CAAYH,SAAZ;AACAV,MAAAA,OAAO,GAAGW,SAAV;AACAP,MAAAA,CAAC,GAAG,CAAC,CAAL;AACD,KAND,MAMO,IAAIE,IAAI,KAAKb,WAAb,EAA0B;AAC/Be,MAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ;;AACA,UAAIN,QAAQ,CAACE,MAAb,EAAqB;AACnBH,QAAAA,MAAM,CAACW,IAAP,CAAY,CAACV,QAAD,IAAaA,QAAzB;AACD;;AACD,aAAO,CAACD,MAAD,EAASF,OAAO,CAACY,SAAR,CAAkBR,CAAC,GAAG,CAAtB,CAAT,CAAP;AACD,KANM,MAMA,IAAIE,IAAI,KAAKZ,WAAb,EAA0B;AAC/B,YAAM,CAACgB,SAAD,EAAYC,SAAZ,IAAyBZ,SAAS,CAACC,OAAO,CAACY,SAAR,CAAkBR,CAAC,GAAG,CAAtB,CAAD,CAAxC;AACAF,MAAAA,MAAM,CAACW,IAAP,CAAYH,SAAZ;AACAV,MAAAA,OAAO,GAAGW,SAAV;AACAP,MAAAA,CAAC,GAAG,CAAC,CAAL;AACD,KALM,MAKA,IAAIE,IAAI,KAAKX,YAAb,EAA2B;AAChC,UAAIQ,QAAQ,CAACE,MAAb,EAAqB;AACnBH,QAAAA,MAAM,CAACW,IAAP,CAAY,CAACV,QAAD,IAAaA,QAAzB;AACD;;AACD,aAAO,CAACD,MAAD,EAASF,OAAO,CAACY,SAAR,CAAkBR,CAAC,GAAG,CAAtB,CAAT,CAAP;AACD,KALM,MAKA,IAAIE,IAAI,KAAKV,SAAb,EAAwB;AAC7B,aAAOI,OAAO,CAACO,MAAR,CAAeH,CAAf,MAAsBP,OAA7B,EAAsC;AACpCO,QAAAA,CAAC;AACF;AACF,KAJM,MAIA,IAAIN,UAAU,CAACgB,QAAX,CAAoBR,IAApB,KAA6BL,QAAQ,KAAK,IAA9C,EAAoD;AACzD,UAAIE,QAAQ,CAACE,MAAb,EAAqB;AACnBH,QAAAA,MAAM,CAACW,IAAP,CAAY,CAACV,QAAD,IAAaA,QAAzB;AACD;;AACDA,MAAAA,QAAQ,GAAG,EAAX;AACD,KALM,MAKA;AACLA,MAAAA,QAAQ,IAAIG,IAAZ;AACD;AACF;;AACD,SAAO,CAACJ,MAAD,EAAS,EAAT,CAAP;AACD;;AAED,SAASH,SAAT","sourcesContent":["const DOUBLEQUOTE = `\"`;\nconst BRACKETLEFT = `(`;\nconst BRACKETRIGHT = `)`;\nconst SEMICOLON = `;`;\nconst NEWLINE = `\\n`;\nconst WHITESPACE = [\" \", \"\\n\", \"\\t\"];\n\nfunction lispLexer(payload = \"\", inString = false) {\n  const tokens = [];\n  let curToken = \"\";\n\n  for (let i = 0; i < payload.length; i++) {\n    const char = payload.charAt(i);\n    if (char === DOUBLEQUOTE && inString === false) {\n      console.log(\"open quote\");\n      const [tokenized, remaining] = lispLexer(payload.substring(i + 1), true);\n      tokens.push(tokenized);\n      payload = remaining;\n      i = -1;\n    } else if (char === DOUBLEQUOTE) {\n      console.log(\"close quote\");\n      if (curToken.length) {\n        tokens.push(+curToken || curToken);\n      }\n      return [tokens, payload.substring(i + 1)];\n    } else if (char === BRACKETLEFT) {\n      const [tokenized, remaining] = lispLexer(payload.substring(i + 1));\n      tokens.push(tokenized);\n      payload = remaining;\n      i = -1;\n    } else if (char === BRACKETRIGHT) {\n      if (curToken.length) {\n        tokens.push(+curToken || curToken);\n      }\n      return [tokens, payload.substring(i + 1)];\n    } else if (char === SEMICOLON) {\n      while (payload.charAt(i) !== NEWLINE) {\n        i++;\n      }\n    } else if (WHITESPACE.includes(char) && inString !== true) {\n      if (curToken.length) {\n        tokens.push(+curToken || curToken);\n      }\n      curToken = \"\";\n    } else {\n      curToken += char;\n    }\n  }\n  return [tokens, \"\"];\n}\n\nexport { lispLexer };\n"],"file":"lexer.js"}